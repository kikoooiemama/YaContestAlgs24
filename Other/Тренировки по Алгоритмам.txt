=====================================================================================================================
01. Тестирование

- Писать работающий код
- Тестировать свой код
- Писать эффективный код 
- Делать это быстро

Сложность алгоритмов.

O(N) = 10, O(NlogN) = 30, O(N2) = 100, O(N3) = 1000, O(1) - нет замедления
2^logN = N

Тестирование.
- покрытие тестами, нагрузочное тестирование (основная часть промышленной разработки) - наша область
- формальная верификация программ (микрокод процесса, финансы, космос?..) - тут ошибки не допустимы! специфичная вещь.

Что тестировать?
- Тесты из условия
- Общие случаи
- Особые случаи 

Последовательности: крайние значения, одинаковые значения, много значений (чекаем время выполнения), последовательность из 1 числа/пустая, отрицательные (неадекватные числа)
=====================================================================================================================
02. Префиксные суммы и два указателя

- Префиксные суммы
- Два указателя

----------Префиксные суммы----------
Префикс - начало чего-либо (массива, строки и т.д.)

Пусть есть массив из N и необходимость отвечать на запросы: Чему равна сумма элементов на интервале [L, R)?

Нужно посчитать суммы на отрезке. Для этого создадим массив, где будем хранить сумму всех предыдущих чисел.

prefixsum[i] = prefixsum[i-1] + nums[i-1]
ВАЖНО! Массив сум на 1 больше по размеру (N+1).
ВАЖНО! Может возникнуть переполнение, если сумма выйдет за пределы max значения.

O(1): sum(L, R) = prefixsum[R] - prefixsum[L]

Недостаток: нельзя менять элементы -> придется пересчитывать все префиксные суммы, а это O(N)!

Реализация RSQ:
def make(nums):
    prefixsum = [0] * (len(nums) + 1)
    for i in range(1, len(nums) + 1):
        prefixsum[i] = prefixsum[i-1] + nums[i-1]
    return prefixsum

# [L, R)
def rsq(prefixsum, l, r):
    return prefixsum[r] - prefixsum[l]

Задачи:
- Дана последовательность N. Найти количество нулей на отрезке для M запросов. O(N+M)
- Дана последовательность N. Нужно найти количество отрезков с нулевой суммой. O(
Одинаковые префиксные суммы означают, что сумма с началом и концом в позициях, на которых достигаются одинаковые суммы, будет равна нулю.
Это популярная задача. Считаем отрезки и для каждой нулевой суммы: cntsum * (cntsum - 1) // 2 - формула суммы арифм. прогрессии.

----------Два указателя----------

Даны отсортированная последовательность чисел N и число K. Необходимо найти количество пар чисел A, B, таких, что B - A > K.

Вариант: Находим 1 пару, а B дальше не проверяем, т.к. по умолчанию будет соответствие (последовательность же отсортирована). Но это все еще N^2.
Идея: После нахождения 1 пары и непроверки дальше B, мы будет для следующего числа A двигать B от индекса найденного ранее. И двигать будем вправо пока не найдем нужный B. Указатель L, R - поисковики, их двигаем только вправо. Таким образом, сложность будет O(N).

Базовая структура:
for condition:
	while condition:

Задача:
- Merge две упорядоченные последовательности в одну. Как? Остаток сливаем автоматом в конец. Тут чисто нужно понять как обработать момент, когда одна из последовательностей заканчивается.
- Найти максимальную по длине подстроку данной строки, такую, что каждый символ встречается в ней не более k раз. O(N^2)
=====================================================================================================================
03.
=====================================================================================================================
04. 
=====================================================================================================================