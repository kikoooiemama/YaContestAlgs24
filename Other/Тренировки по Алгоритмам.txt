=====================================================================================================================
01. Тестирование

- Писать работающий код
- Тестировать свой код
- Писать эффективный код 
- Делать это быстро

Сложность алгоритмов.

O(N) = 10, O(NlogN) = 30, O(N2) = 100, O(N3) = 1000, O(1) - нет замедления
2^logN = N

Тестирование.
- покрытие тестами, нагрузочное тестирование (основная часть промышленной разработки) - наша область
- формальная верификация программ (микрокод процесса, финансы, космос?..) - тут ошибки не допустимы! специфичная вещь.

Что тестировать?
- Тесты из условия
- Общие случаи
- Особые случаи 

Последовательности: крайние значения, одинаковые значения, много значений (чекаем время выполнения), последовательность из 1 числа/пустая, отрицательные (неадекватные числа)
=====================================================================================================================
02. Префиксные суммы и два указателя

- Префиксные суммы
- Два указателя

----------Префиксные суммы----------
Префикс - начало чего-либо (массива, строки и т.д.)

Пусть есть массив из N и необходимость отвечать на запросы: Чему равна сумма элементов на интервале [L, R)?

Нужно посчитать суммы на отрезке. Для этого создадим массив, где будем хранить сумму всех предыдущих чисел.

prefixsum[i] = prefixsum[i-1] + nums[i-1]
ВАЖНО! Массив сум на 1 больше по размеру (N+1).
ВАЖНО! Может возникнуть переполнение, если сумма выйдет за пределы max значения.

O(1): sum(L, R) = prefixsum[R] - prefixsum[L]

Недостаток: нельзя менять элементы -> придется пересчитывать все префиксные суммы, а это O(N)!

Реализация RSQ:
def make(nums):
    prefixsum = [0] * (len(nums) + 1)
    for i in range(1, len(nums) + 1):
        prefixsum[i] = prefixsum[i-1] + nums[i-1]
    return prefixsum

# [L, R)
def rsq(prefixsum, l, r):
    return prefixsum[r] - prefixsum[l]

Задачи:
- Дана последовательность N. Найти количество нулей на отрезке для M запросов. O(N+M)
- Дана последовательность N. Нужно найти количество отрезков с нулевой суммой. O(
Одинаковые префиксные суммы означают, что сумма с началом и концом в позициях, на которых достигаются одинаковые суммы, будет равна нулю.
Это популярная задача. Считаем отрезки и для каждой нулевой суммы: cntsum * (cntsum - 1) // 2 - формула суммы арифм. прогрессии.

----------Два указателя----------

Даны отсортированная последовательность чисел N и число K. Необходимо найти количество пар чисел A, B, таких, что B - A > K.

Вариант: Находим 1 пару, а B дальше не проверяем, т.к. по умолчанию будет соответствие (последовательность же отсортирована). Но это все еще N^2.
Идея: После нахождения 1 пары и непроверки дальше B, мы будет для следующего числа A двигать B от индекса найденного ранее. И двигать будем вправо пока не найдем нужный B. Указатель L, R - поисковики, их двигаем только вправо. Таким образом, сложность будет O(N).

Базовая структура:
for condition:
	while condition:

Задача:
- Merge две упорядоченные последовательности в одну. Как? Остаток сливаем автоматом в конец. Тут чисто нужно понять как обработать момент, когда одна из последовательностей заканчивается.
- Найти максимальную по длине подстроку данной строки, такую, что каждый символ встречается в ней не более k раз. O(N^2)
=====================================================================================================================
03. Стеки, очереди, деки

----------Стеки----------
Стек - структура, которая реализует типа "стопка книжек". Снизу, с середины взять не может. Сверху кладем - сверху берем.
- Последний пришел - первый вышел
- Last in - First Out (LIFO)
- push(x) - добавить элемент х
- pop - удалить элемент из вершины стека

Задачи:
- Правильная скобочная последовательность: (), (()), ()(()())
- Правильная скобочная последовательность с несколькими видами скобок: [], {[]()}, []{}()

Как считать правильность?
Для одного вида скобок не должны закрываться неоткрытые скобки, в конце все открытые скобки должны быть закрыты.
Идея: счетчиком плюсуем открытые и вычитаем закрытые, если счетчик равен 0 - все верно.

Если видов скобок больше, то можно заводить несколько счетчиков. Однако, это не будет работать :) Пример: (()[[])]
Что же делать? Использовать стек.
Встретили закрывающую - проверили, что стек не пуст, на вершине лежит соответствующая открывающая, и убрали ее. В конце
стек должен оказаться пустым.

Это применимо не только для скобок, но и для тегов (например, HTML, и т.д.)

Python:
push - append
pop - pop

Как считать?
Ищем самые глубоко вложенные скобки. Внутри самых вложенных скобок выполняем операции по убыванию приоритета и заменяем
два операнда и операцию на одно число. Когда внутри скобок остается одно число - убираем скобки и начинаем сначала.

Инфиксная запись (операция между операндами):
    6 + 3 * (1 + 4 * 5) * 2
Постфиксная запись (сначала операнды, потом операции):
    6 3 1 4 5 * + * 2 * +

Мы берем постфиксную запись и складываем в стек, когда доходим до операции - берем 2 верхних числа - получаем новое
число и кладем его в стек (сверху) и идем дальше. Для вычитания и деления берем вначале нижний.

Давайте научимся переводить из инфиксной записи в постфиксную.
- Операнд сразу попадает в ответ
- Операция выталкивает в ответ все операции с больше либо равным приоритетом и кладется в стек
- Открывающая скобка кладется в стек
- Закрывающая скобка выталкивает в ответ все операции до открывающей скобки, затем удаляет открывающую скобку
- В конце все операции выписываются в ответ (те что лежат в стеке).

Унарная запись: -6*(-8) переводим в 0-6*(0-8)

Еще задача:
- Для каждого числа определить индекс ближайшего меньшего числа, которое находится правее текущего.
(Прямоугольник вписанный в столбчатую диаграмму: хотим за O(n))

Поиск ближайшего меньшего СПРАВА:
- Будем хранить в стеке пары из значения и индекса элементов, для которых ответ еще не найден.
- Пойдем по последовательности слева направо
- Очередной элемент выталкивает из стека все элементы с большим значением - для них он является ответом. После этого
ложится в стек сам.
- Таким образом, стек всегда будет хранить возрастающую последовательность.
- При выталкивании - записываем позицию элемента, который будет выталкивать (именно индекс, видео: 44-00).
Получили лист: для каждого элемента найден индекс ближайшего меньшего справа.
Аналогично для ближайшего меньшего СЛЕВА. Таким образом, можно легко посчитать площадь прямоугольника. И пройдя 1 раз
по списку нашли бы min/max площадь.

----------Очереди и деки----------
- Первый пришел - первый вышел
- First in - First out (FIFO)
- push(x) - добавить элемент в конец очереди
- pop - добавить элемент из начала очереди

Выгоднее всего "двигать кассу" + кольцевой буфер. Указатель двигается по кругу. Его проще всего реализовать с помощью
остатков от деления. "КОЛЬЦЕВОЙ БУФФЕР" - очень выгодная вещь.

ДЕК (Deque)
В дек можно добавлять и забирать как с начала, так и с конца:
double ended queue - deque

Методы можно назвать:
push_front, pop_front, push_back, pop_back

Задача: Дана последовательность N, для каждого окна длиной K необходимо посчитать минимум в нем.

Идея: дек кандидатов в минимумы. Новый элемент выталкивает все большие элементы, так как все следующие окна содержат
новый элемент, а старые элементы уйдут из окна раньше. Таким образом, в деке будет возрастающая последовательность.
Когда при сдвиге окна слева оказывается минимум - удаляем его из начала дека.

----------Рекурсия----------
От рекурсии можно избавиться, написав свой стек.

При каждом запуске функции в стеке выделяется память под локальные переменные, параметры. Там же запоминается, откуда
продолжить выполнение функции, если мы запустили какую-то другую функцию.

Когда функция заканчивается, ее переменные и параметры удаляются из стека, а выполнение продолжается с запомненного места.

def factorial(n):
    if n == 1:
        return 1
    prevfac = factorial(n - 1)
    return n*prevfac

Стек операций:
n = 1, pf = 1 (возвращает в n = 2 единицу)
n = 2, pf = 1
n = 3, pf = 2
n = 4, pf = 6

result = 24
=====================================================================================================================
04. 
=====================================================================================================================