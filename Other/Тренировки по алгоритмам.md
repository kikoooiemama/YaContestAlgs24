## 1. Тестирование

- Писать работающий код
- Тестировать свой код
- Писать эффективный код
- Делать это быстро

**Сложность алгоритмов.**

- O(N) = 10, O(NlogN) = 30, O(N2) = 100, O(N3) = 1000, O(1) - нет замедления
- 2^logN = N

**Тестирование.**

- покрытие тестами, нагрузочное тестирование (основная часть промышленной разработки) - наша область
- формальная верификация программ (микрокод процесса, финансы, космос?..) - тут ошибки не допустимы! специфичная вещь.

**Что тестировать?**

- Тесты из условия
- Общие случаи
- Особые случаи

Последовательности: крайние значения, одинаковые значения, много значений (чекаем время выполнения), последовательность
из 1 числа/пустая, отрицательные (неадекватные числа)

## 2. Префиксные суммы и два указателя

- Префиксные суммы
- Два указателя

### Префиксные суммы
Префикс - начало чего-либо (массива, строки и т.д.)

Пусть есть массив из N и необходимость отвечать на запросы: Чему равна сумма элементов на интервале [L, R)?

Нужно посчитать суммы на отрезке. Для этого создадим массив, где будем хранить сумму всех предыдущих чисел.

prefixsum[i] = prefixsum[i-1] + nums[i-1]

**ВАЖНО!** Массив сум на 1 больше по размеру (N+1). ВАЖНО! Может возникнуть переполнение, если сумма выйдет за пределы max
значения.
```
O(1): sum(L, R) = prefixsum[R] - prefixsum[L]
```
Недостаток: нельзя менять элементы -> придется пересчитывать все префиксные суммы, а это O(N)!

Реализация RSQ:
```
def make(nums):
    prefixsum = [0] * (len(nums) + 1)
    for i in range(1, len(nums) + 1):
    prefixsum[i] = prefixsum[i-1] + nums[i-1]
    return prefixsum
```
```
# [L, R)
def rsq(prefixsum, l, r):
    return prefixsum[r] - prefixsum[l]
```
Задачи:

- Дана последовательность N. Найти количество нулей на отрезке для M запросов. O(N+M)
- Дана последовательность N. Нужно найти количество отрезков с нулевой суммой. O(
  Одинаковые префиксные суммы означают, что сумма с началом и концом в позициях, на которых достигаются одинаковые
  суммы, будет равна нулю. Это популярная задача. Считаем отрезки и для каждой нулевой суммы: cntsum * (cntsum - 1) // 2
  - формула суммы арифм. прогрессии.

### Два указателя

Даны отсортированная последовательность чисел N и число K. Необходимо найти количество пар чисел A, B, таких, что B -
A > K.

Вариант: Находим 1 пару, а B дальше не проверяем, т.к. по умолчанию будет соответствие (последовательность же
отсортирована). Но это все еще N^2. Идея: После нахождения 1 пары и непроверки дальше B, мы будет для следующего числа A
двигать B от индекса найденного ранее. И двигать будем вправо пока не найдем нужный B. Указатель L, R - поисковики, их
двигаем только вправо. Таким образом, сложность будет O(N).

Базовая структура:
```
for condition:
    while condition:
```
Задачи:
- Merge две упорядоченные последовательности в одну. Как? Остаток сливаем автоматом в конец. Тут чисто нужно понять как
  обработать момент, когда одна из последовательностей заканчивается.
- Найти максимальную по длине подстроку данной строки, такую, что каждый символ встречается в ней не более k раз. O(N^2)

## 3. Стеки, очереди, деки

### Стеки
Стек - структура, которая реализует типа "стопка книжек". Снизу, с середины взять не может.
Сверху кладем - сверху берем.

- Последний пришел - первый вышел
- Last in - First Out (LIFO)
- push(x) - добавить элемент х
- pop - удалить элемент из вершины стека

Задачи:

- Правильная скобочная последовательность: (), (()), ()(()())
- Правильная скобочная последовательность с несколькими видами скобок: [], {[]()}, []{}()

Как считать правильность? Для одного вида скобок не должны закрываться неоткрытые скобки, в конце все открытые скобки
должны быть закрыты. Идея: счетчиком плюсуем открытые и вычитаем закрытые, если счетчик равен 0 - все верно.

Если видов скобок больше, то можно заводить несколько счетчиков. Однако, это не будет работать :) Пример: (()[[])]
Что же делать? Использовать стек. Встретили закрывающую - проверили, что стек не пуст, на вершине лежит соответствующая
открывающая, и убрали ее. В конце стек должен оказаться пустым.

Это применимо не только для скобок, но и для тегов (например, HTML, и т.д.)

Как считать? Ищем самые глубоко вложенные скобки. Внутри самых вложенных скобок выполняем операции по убыванию
приоритета и заменяем два операнда и операцию на одно число. Когда внутри скобок остается одно число - убираем скобки и
начинаем сначала.

### Постфиксная запись
**Инфиксная запись (операция между операндами):**
6 + 3 * (1 + 4 * 5) * 2 

**Постфиксная запись (сначала операнды, потом операции):**
6 3 1 4 5 * + * 2 * +

**Как вычислять по постфиксной записи?**

Мы берем постфиксную запись и складываем в стек, когда доходим до операции - берем 2 верхних числа - получаем новое
число и кладем его в стек (сверху) и идем дальше. Для вычитания и деления берем вначале нижний.

**Как получить постфиксную запись?**

- Операнд сразу попадает в ответ
- Операция выталкивает в ответ все операции с больше либо равным приоритетом и кладется в стек
- Открывающая скобка кладется в стек
- Закрывающая скобка выталкивает в ответ все операции до открывающей скобки, затем удаляет открывающую скобку
- В конце все операции выписываются в ответ (те что лежат в стеке).

Унарная запись: -6*(-8) переводим в 0-6*(0-8)

Задача:

Для каждого числа определить индекс ближайшего меньшего числа, которое находится правее текущего 
(Прямоугольник вписанный в столбчатую диаграмму: хотим за O(n)).

Поиск ближайшего меньшего СПРАВА:
- Будем хранить в стеке пары из значения и индекса элементов, для которых ответ еще не найден.
- Пойдем по последовательности слева направо
- Очередной элемент выталкивает из стека все элементы с большим значением - для них он является ответом. После этого
  ложится в стек сам.
- Таким образом, стек всегда будет хранить возрастающую последовательность.
- При выталкивании - записываем позицию элемента, который будет выталкивать (именно индекс, видео: 44-00). Получили
  лист: для каждого элемента найден индекс ближайшего меньшего справа. Аналогично для ближайшего меньшего СЛЕВА. Таким
  образом, можно легко посчитать площадь прямоугольника. И пройдя 1 раз по списку нашли бы min/max площадь.

### Очереди и деки

#### Очередь
- Первый пришел - первый вышел
- First in - First out (FIFO)
- push(x) - добавить элемент в конец очереди
- pop - добавить элемент из начала очереди

Выгоднее всего "двигать кассу" + кольцевой буфер. Указатель двигается по кругу. Его проще всего реализовать с помощью
остатков от деления. "КОЛЬЦЕВОЙ БУФФЕР" - очень выгодная вещь.

#### ДЕК (Deque)
В дек можно добавлять и забирать как с начала, так и с конца:
"double ended queue" - deque

Методы можно назвать:
push_front, pop_front, push_back, pop_back

Задача: Дана последовательность N, для каждого окна длиной K необходимо посчитать минимум в нем.

Идея: дек кандидатов в минимумы. Новый элемент выталкивает все большие элементы, так как все следующие окна содержат
новый элемент, а старые элементы уйдут из окна раньше. Таким образом, в деке будет возрастающая последовательность.
Когда при сдвиге окна слева оказывается минимум - удаляем его из начала дека.

### Рекурсия

От рекурсии можно избавиться, написав свой стек.

При каждом запуске функции в стеке выделяется память под локальные переменные, параметры. Там же запоминается, откуда
продолжить выполнение функции, если мы запустили какую-то другую функцию.

Когда функция заканчивается, ее переменные и параметры удаляются из стека, а выполнение продолжается с запомненного
места.

```
def factorial(n):
    if n == 1:
        return 1 
    prevfac = factorial(n - 1)
    return n*prevfac
```
Стек операций:
- n = 1, pf = 1 (возвращает в n = 2 единицу)
- n = 2, pf = 1 n = 3, pf = 2 n = 4, pf = 6
- result = 24

## 4. Деревья, представления и обходы

* Дерево.
* Верхушка дерева - корень.
* Внизу - листья (лист - нет своих потомков).
* Также можно использовать: сыновья, отцы, потомки, предки и т.д.
* Поддерево - в качество корня выбираем какой-то элемент. Лист тоже поддерево.
* Глубина - высота дерева
* Сбалансированное дерево - у всех узлов примерно одинаковое количество потомков.
* Размер дерева: Сумма всех детей и размеров всех детей + 1

В python можно хранить деревья с помощью вложенных списков:
```
['Святослав', [['Ярослав', []], ['Олег', []]]
```
Примеры: json, система папок 

Метод деревьев: листья возвращают значение наверх с помощью рекурсивной функции
### Деревья поиска

#### Бинарное дерево поиска
* У каждого узла - ключ и два сына
* В левом поддереве ключи меньше, а в правом больше
* Значение корня больше значения левого потомка и меньше значения правого потомка
* Если ключи поступают в случайном порядке, то глубина дерева будет O(log N) (т.е. находить элементы за log N)
```
[1, [[2, None], [3, None]]
```

**Поиск ключа:**

Идем к левому сыну, вызываем рекурсивную функцию (на проверку) и так далее пока не найдем нужный ключ.
Либо можно обойтись обычным циклом, используя правило, что в левом поддереве ключи меньше.

**Добавление ключа:**

Смотрим на корень, допустим корень меньше (8 < 9). Тогда нужно добавлять в правое поддерево. Смотрим дальше на узел, 
допустим добавляемое число меньше (9 < 10) и левого сына у узла нет: создаем левую ветку и вставляем туда новый элемент.

**Удаление листа:**

Находим лист, заменяем у предка значение листа -> None. А можно сделать каждому узлу 3 значение - ссылка на предка, тогда 
находим удаляемый элемент, запоминаем его предка и тогда у него удаляем.

**Удаление ключа с 1 потомком:**

Если у ключа есть дети, то детей нужно привязать к предку удаляемого ключа. 

**Удаление ключа с 2 потомками:**

Как будут смещаться потомки? Заменить удаляемый ключ на 
**"значение самого маленького числа, которое больше удаляемого"**
ИЛИ 
**"значение самого большого числа, которое меньше удаляемого"** в поддереве. 

Как их найти? Давайте научимся самый большой элемент в поддереве: приходим в поддерево и ищем самый маленький элемент 
в дерево -> он находится слева -> как только слева никого не осталось -> элемент найден

Тут тоже не нужна рекурсия. Сложность: О(1) - по памяти, О(H-высоты) - по времени.

**Важно!** Если бинарное дерево сбалансировано, то количество элементов: N = 2**(K+1) - 1. 
Количество слагаемых, где каждое вдвое больше предыдущего будет равно log2 N.
Если N = 1000_000_000, тогда глубина k ~ 30.

#### Обход дерева
Если мы обойдем все элементы дерева, то мы получим все элементы в порядке возрастания - один из способов сортировать массив.
```
rec(node):
  rec(node_left)
  print(node_key)
  rec(node_left)
  print(node_right)
```

Если есть указатель на предка - можно без рекурсии.
### Задачи на деревья

Посмотрим задачи на другие деревья, которые не являются бинарными. Единственное отличие - не 2 потомка, а список.

#### Задача: кто предки и потомки
Идея: будем записывать время входа и время выхода из рекурсивной функции. Или время будет тикать каждый раз, когда мы 
запускаем рекурсивную функцию. 35:30.

* Получаем аналогию со скобочной последовательностью. Потомок вложен в предка: (()()((()())))
* Легко проверить является ли элемент потомком другого. Если отрезок обработки элемента вложен в отрезок обработки 
другого - значит потомок.
* О(N) - подсчет, O(1) - на проверку.

#### Задача: диаметр дерева
Диаметр - максимальное расстояние, количество ребер между 2 самыми удаленными вершинами. 

Идея: для каждого поддерева узнать глубину, можно сделать рекурсией, например. Задаем что у листа глубина 1 и так 
наверх, складывая суммы и находя max для детей. Дальше для каждой вершины дерева мы выбираем 2х самых глубоких детей и 
ищем max.

Самый длинный путь может проходить не через корень!

**Другой способ:** Находим самую далекую (глубокую) от корня вершину. Делаем ее корнем и находим от нее самую глубокую вершину.
Сложность видимо O(2N). Способ очень хороший, т.к. мы переподвесили дерево на другую вершину.

#### Задача: срочное сообщение
* В компании сообщение передается от начальника к подчиненному или от подчиненного к начальнику за единицу времени.
* Двое людей без подчиненных могут передать друг другу сообщение за единицу времени на кофе пойнте.
* Будет много запросов о передаче сообщения.

Чел 11 к Чел 3 - запрос на передачу. Мы можем подсчитать для каждой вершины ее расстояние от корня и передать сообщение через корень. 
Это невсегда эффективно, если Челы находятся на одной ветке от начальника. Что делать?

Можно подвесить дерево за Чел 11 или Чел 3 и от него посчитаем расстояние по дереву. 

Помним, что есть обмен через подчиненных. Подвесим дерево за Чел 11 и находим его самого близкого листа (минимальная глубина).
Аналогично подвесим Чел 3. Итого: dist1 + dist2 + 1

И выбираем из этого минимальный путь: либо по ребрам, либо через подчиненных.

Что делать если запросов много? 
Нужно научиться быстро искать вершину, где путь перегибается: LCA (Lowest common ancestor, ближайший общий предок)

Также для каждой вершины нужно найти ближайший лист: запуститься одновременно от всех листьев и от них шагать и писать самое маленькое число (обход в ширину)?

#### Задача: коровники
* В каждом узле дерева пасется корова
* В узлах дерева можно построить К коровников, где коровы будут прятаться от дождя
* Необходимо определить места для строительства коровников, чтобы максимальный путь коровы до ближайшего коровника был минимальным.

Упростим:
Пусть корова будет ходить не более чем на M от коровника. 

Идея: Для каждой вершины считаем расстояние до листьев и будем строить коровник там, где расстояние будет M. 
Т.е. расстояние от вершины до листьев <= M. 

Если справа есть кусок, то мы делаем отрицательное расстояние для правых - это хак. Его можно заменить доп. переменной.

Но задача была оптимально определить места коровников, чтобы минимизировать расстояния. Что делать? 

**Бинарный поиск по ответу** - был в предыдущих сезонах тренировок. 
Берем расстояние M=n и проверяем для каждого n, увеличивая расстояние, пока не найдем k или меньше коровников.
Бинарный поиск позволит это сделать за log N.

### Балансировка бинарных деревьев
Бинарные деревья поиска. Как их балансировать?

#### Split
Научимся разрезать дерево на два по ключу.
"Декартово дерево"
Идея: Берем обычное бинарное дерево и учимся резать его на 2 дерева по ключу, таким образом, чтобы в левом поддереве
были все числа меньше или равные ключу, а в правом поддереве все числа больше этого ключа.

Как приклеивать?
#### Merge
Научимся склеивать два дерева.

Выбираем корень с вероятностью. В левом дереве 5 элементов, в правом 4 элемента. 
Сгенерируем рандом от 1 до 9, если > 5, то в качестве корня берем право, наоборот лево.
* Если выпало левое, тогда ты оказался в меньшем дереве, значит твои левые сыновья остаются как было, а правое = 
результат склеивания правого сына и правого дерева. Ну и рекурсивно вызываем "merge" для них, пока они не склеятся.
* За счет эвристики выбирается корень из двух элементов можно показать, что глубина дерева будет равна логарифму.

#### Вставка элемента
Есть декартово дерево. Нужно вставить элемент Х.

Если нам нужно вставить элемент Х, то разрежем дерево по Х, создадим новое дерево с элементом Х и сольем 3 дерева.
```
Режем дерево пополам. 
L < X, R > X

L, R: split(x2, Tree, x)
L = merge(L, x)
Tree = merge(L, R) 
```
#### Удаление элемента
Разрежем дерево на три: с ключами меньше Х, с ключом Х, с ключами больше Х. Среднее удалим и склеим левое и правое.
```
L, R = split(tree, x)
L, tmp = split(L, x-1)
tree = merge(L, R)
```

Совет: научиться писать "декартово дерево" и потренировать. Это даст возможность делать сбалансированные деревья, что 
позволяет насчитывать любые статистики: 
* размеры поддеревьев,
* k-порядковая статистика среди набора элементов, 
* определение порядкового номера элемента по ключу,
* вырезать и вставлять тексты за log N,
* вставка в массив за log N,
* и многое другое

Как обойти ограничение на рекурсию в Python:
* *setrecursionlimit* - его можно менять. По-умолчанию стоит 10_000.
